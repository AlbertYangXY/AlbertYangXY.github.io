{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{372:function(e,t,r){\"use strict\";r.r(t);var s=r(0),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"prometheus-学习笔记\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-学习笔记\"}},[e._v(\"#\")]),e._v(\" Prometheus 学习笔记\")]),e._v(\" \"),r(\"hr\"),e._v(\" \"),r(\"h2\",{attrs:{id:\"介绍\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#介绍\"}},[e._v(\"#\")]),e._v(\" 介绍\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"什么是-prometheus？\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是-prometheus？\"}},[e._v(\"#\")]),e._v(\" 什么是 Prometheus？\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus是最初在SoundCloud上构建的开源系统监视和警报工具包 。自2012年成立以来，许多公司和组织都采用了Prometheus，该项目拥有非常活跃的开发人员和用户社区。现在，它是一个独立的开源项目，并且独立于任何公司进行维护。为了强调这一点并阐明项目的治理结构，Prometheus 在2016年加入了 Cloud Native Computing Foundation，这是继Kubernetes之后的第二个托管项目。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"prometheus-的特征\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-的特征\"}},[e._v(\"#\")]),e._v(\" Prometheus 的特征\")]),e._v(\" \"),r(\"p\",[e._v(\"Pormetheus 的主要特点是：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"强大的多维度数据模型：\")]),e._v(\" \"),r(\"ol\",[r(\"li\",[e._v(\"时间序列数据通过 metric 名和键值对来区分。\")]),e._v(\" \"),r(\"li\",[e._v(\"所有的 metrics 都可以设置任意的多维标签。\")]),e._v(\" \"),r(\"li\",[e._v(\"数据模型更随意，不需要刻意设置为以点分隔的字符串。\")]),e._v(\" \"),r(\"li\",[e._v(\"可以对数据模型进行聚合，切割和切片操作。\")]),e._v(\" \"),r(\"li\",[e._v(\"支持双精度浮点类型，标签可以设为全 unicode。\")])])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"灵活而强大的查询语句（PromQL）：在同一个查询语句，可以对多个 metrics 进行乘法、加法、连接、取分数位等操作。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"易于管理： Prometheus server 是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"高效：平均每个采样点仅占 3.5 bytes，且一个 Prometheus server 可以处理数百万的 metrics。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"使用 pull 模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的 metrics。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"可以采用 push gateway 的方式把时间序列数据推送至 Prometheus server 端。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"可以通过服务发现或者静态配置去获取监控的 targets。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"有多种可视化图形界面。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"易于伸缩。\")])])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"prometheus-的组件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-的组件\"}},[e._v(\"#\")]),e._v(\" Prometheus 的组件\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus生态系统包含多个组件，其中许多是可选的：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Prometheus Server: 用于收集和存储时间序列数据。\")]),e._v(\" \"),r(\"li\",[e._v(\"Client Library: 客户端库，为需要监控的服务生成相应的 metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 metrics。\")]),e._v(\" \"),r(\"li\",[e._v(\"Push Gateway: 主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。\")]),e._v(\" \"),r(\"li\",[e._v(\"Exporters: 用于暴露已有的第三方服务的 metrics 给 Prometheus。\")]),e._v(\" \"),r(\"li\",[e._v(\"Alertmanager: 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。\")]),e._v(\" \"),r(\"li\",[e._v(\"一些其他的工具。\")])]),e._v(\" \"),r(\"p\",[e._v(\"大多数Prometheus组件都是用Go编写的，因此易于构建和部署为静态二进制文件。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"prometheus-的架构\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-的架构\"}},[e._v(\"#\")]),e._v(\" Prometheus 的架构\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus 的整体架构以及生态系统组件如下图所示：\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"prometheus-arch.jpg\",alt:\"\"}})]),e._v(\" \"),r(\"p\",[e._v(\"大体工作流程：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Prometheus server 定期从配置好的 jobs 或者 exporters 中拉 metrics，或者接收来自Pushgateway 发过来的 metrics，或者从其他的 Prometheus server 中拉 metrics。\")]),e._v(\" \"),r(\"li\",[e._v(\"Prometheus server 在本地存储收集到的 metrics，并运行已定义好的 alert.rules，记录新的时间序列或者向 Alertmanager 推送警报。\")]),e._v(\" \"),r(\"li\",[e._v(\"Alertmanager 根据配置文件，对接收到的警报进行处理，发出告警。\")]),e._v(\" \"),r(\"li\",[e._v(\"在图形界面中，可视化采集数据。\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"prometheus-适合什么场景\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-适合什么场景\"}},[e._v(\"#\")]),e._v(\" Prometheus 适合什么场景\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus非常适合记录任何纯数字时间序列。它既适合以机器为中心的监视，也适合于高度动态的面向服务的体系结构的监视。在微服务世界中，它对多维数据收集和查询的支持是一种特别的优势。\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus 是专为提高系统可靠性而设计的，它可以在断电期间快速诊断问题，每个 Prometheus Server 都是相互独立的，不依赖于网络存储或其他远程服务。当基础架构出现故障时，你可以通过 Prometheus 快速定位故障点，而且不会消耗大量的基础架构资源。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"prometheus-不适合什么场景\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#prometheus-不适合什么场景\"}},[e._v(\"#\")]),e._v(\" Prometheus 不适合什么场景\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus 非常重视可靠性，即使在出现故障的情况下，你也可以随时查看有关系统的可用统计信息。如果你需要百分之百的准确度，例如按请求数量计费，那么 Prometheus 不太适合你，因为它收集的数据可能不够详细完整。这种情况下，你最好使用其他系统来收集和分析数据以进行计费，并使用 Prometheus 来监控系统的其余部分。\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"概念\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概念\"}},[e._v(\"#\")]),e._v(\" 概念\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"数据模型\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#数据模型\"}},[e._v(\"#\")]),e._v(\" 数据模型\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus 中存储的数据为时间序列，是由 metric 的名字和一系列的标签（键值对）唯一标识的，不同的标签则代表不同的时间序列。\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"metric 名字：该名字应该具有语义，一般用于表示 metric 的功能，例如：http_requests_total, 表示 http 请求的总数。其中，metric 名字由 ASCII 字符，数字，下划线，以及冒号组成，且必须满足正则表达式 [a-zA-Z_:][a-zA-Z0-9_:]*。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v('标签：使同一个时间序列有了不同维度的识别。例如 http_requests_total{method=\"Get\"} 表示所有 http 请求中的 Get 请求。当 method=\"post\" 时，则为新的一个 metric。标签中的键由 ASCII 字符，数字，以及下划线组成，且必须满足正则表达式 [a-zA-Z_:][a-zA-Z0-9_:]*。')])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"样本：实际的时间序列，每个序列包括一个 float64 的值和一个毫秒级的时间戳。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"格式：\"),r(\"metric\",{attrs:{name:\"\"}},[e._v(\"{\"),r(\"label\",{attrs:{name:\"\"}},[e._v(\"=\"),r(\"label\",{attrs:{value:\"\"}},[e._v(', …}，例如：http_requests_total{method=\"POST\",endpoint=\"/api/tracks\"}。')])])])],1)])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"指标类型\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#指标类型\"}},[e._v(\"#\")]),e._v(\" 指标类型\")]),e._v(\" \"),r(\"p\",[e._v(\"Prometheus客户端库提供了四种核心度量标准类型。这些仅在客户端库（以启用针对特定类型的使用量身定制的API）和有线协议中有所区别。Prometheus服务器尚未使用类型信息，而是将所有数据展平为未键入的时间序列。将来可能会改变。\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"counter（计数器）\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#counter（计数器）\"}},[e._v(\"#\")]),e._v(\" Counter（计数器）\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[r(\"p\",[e._v(\"Counter 类型代表一种样本数据单调递增的指标，即只增不减，除非监控系统发生了重置。例如，你可以使用 counter 类型的指标来表示服务的请求数、已完成的任务数、错误发生的次数等。\")])]),e._v(\" \"),r(\"li\",[r(\"p\",[e._v(\"不要将 counter 类型应用于样本数据非单调递增的指标，例如：当前运行的进程数量（应该用 Gauge 类型）。\")])])]),e._v(\" \"),r(\"p\",[e._v('例如，查询 http_requests_total{method=\"get\", job=\"Prometheus\", handler=\"query\"} 返回 8，10 秒后，再次查询，则返回 14。')]),e._v(\" \"),r(\"h4\",{attrs:{id:\"gauge-（计量器）\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#gauge-（计量器）\"}},[e._v(\"#\")]),e._v(\" Gauge （计量器）\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"Gauge 类型表示单个数值，可以任意地上升和下降的度量。通常用于测量值，例如温度或当前的内存使用量，还用于可能上升和下降的“计数”，例如并发请求数。\")])]),e._v(\" \"),r(\"p\",[e._v('例如：go_goroutines{instance=\"172.17.0.2\", job=\"Prometheus\"} 返回值 147，10 秒后返回 124。')]),e._v(\" \"),r(\"h4\",{attrs:{id:\"histogram（直方图）\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#histogram（直方图）\"}},[e._v(\"#\")]),e._v(\" Histogram（直方图）\")]),e._v(\" \"),r(\"p\",[e._v(\"Histogram 在一段时间范围内对数据进行采样（通常是请求持续时间或响应大小等），并将其计入可配置的存储桶（bucket）中，后续可通过指定区间筛选样本，也可以统计样本总数，最后一般将数据展示为直方图。\\nHistogram 类型的样本会提供三种指标（假设指标名称为 <basename>）：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"样本的值分布在 bucket 中的数量，命名为 \"),r(\"basename\",[e._v('_bucket{le=\"<上边界>\"}。解释的更通俗易懂一点，这个值表示指标值小于等于上边界的所有样本数量。')])],1),e._v(\" \"),r(\"li\",[e._v(\"所有样本值的大小总和，命名为 <basename>_sum。\")]),e._v(\" \"),r(\"li\",[e._v('样本总数，命名为 <basename>_count 值和 <basename>_bucket{le=\"+Inf\"} 相同。')])]),e._v(\" \"),r(\"h4\",{attrs:{id:\"summary-（汇总）\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#summary-（汇总）\"}},[e._v(\"#\")]),e._v(\" Summary （汇总）\")]),e._v(\" \"),r(\"p\",[e._v(\"与 Histogram 类型类似，用于表示一段时间内的数据采样结果（通常是请求持续时间或响应大小等），但它直接存储了分位数（通过客户端计算，然后展示出来），而不是通过区间来计算。\\nSummary 类型的样本也会提供三种指标（假设指标名称为 <basename>）：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v('样本值的分位数分布情况，命名为 <basename>{quantile=\"<φ>\"}。')]),e._v(\" \"),r(\"li\",[e._v(\"所有样本值的大小总和，命名为 <basename>_sum。\")]),e._v(\" \"),r(\"li\",[e._v(\"样本总数，命名为 <basename>_count。\")])]),e._v(\" \"),r(\"h4\",{attrs:{id:\"histogram-与-summary-的异同\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#histogram-与-summary-的异同\"}},[e._v(\"#\")]),e._v(\" Histogram 与 Summary 的异同\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"它们都包含了 <basename>_sum 和 <basename>_count 指标\")]),e._v(\" \"),r(\"li\",[e._v(\"Histogram 需要通过 <basename>_bucket 来计算分位数\")]),e._v(\" \"),r(\"li\",[e._v(\"而 Summary 则直接存储了分位数的值。\")])]),e._v(\" \"),r(\"h3\",{attrs:{id:\"作业和实例\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#作业和实例\"}},[e._v(\"#\")]),e._v(\" 作业和实例\")]),e._v(\" \"),r(\"p\",[e._v(\"在Prometheus术语中，你可以scrape（刮擦）的端点称为 实例，通常对应于单个进程。一组同种类型的 instances（主要用于保证可扩展性和可靠性），\")]),e._v(\" \"),r(\"p\",[e._v(\"例如：具有四个复制instances（实例）的API服务器job作业:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"job：api-server\\n\"),r(\"ul\",[r(\"li\",[e._v(\"实例1： 1.2.3.4:5670\")]),e._v(\" \"),r(\"li\",[e._v(\"实例2： 1.2.3.4:5671\")]),e._v(\" \"),r(\"li\",[e._v(\"实例3： 5.6.7.8:5670\")]),e._v(\" \"),r(\"li\",[e._v(\"实例4： 5.6.7.8:5671\")])])])]),e._v(\" \"),r(\"h4\",{attrs:{id:\"自动生成的标签和时间序列\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自动生成的标签和时间序列\"}},[e._v(\"#\")]),e._v(\" 自动生成的标签和时间序列\")]),e._v(\" \"),r(\"p\",[e._v(\"当Prometheus scrape（刮擦）目标时，它会自动在scrape的时间序列上附加一些标签，用来识别scrape的目标:\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"job：目标所属的已配置job名称。\")]),e._v(\" \"),r(\"li\",[e._v(\"instance：<host>:<port> 已刮擦目标URL的一部分。\")])]),e._v(\" \"),r(\"p\",[e._v(\"对于每次实例 scrape（刮擦) ,Prometheus都会在以下时间序列中存储样本：\")]),e._v(\" \"),r(\"ul\",[r(\"li\",[e._v(\"up{job=”\\\\ “, instance=”\\\\ “}：1如果实例是健康的，即可达，或者0刮擦失败。\")]),e._v(\" \"),r(\"li\",[e._v(\"scrape_duration_seconds{job=”\\\\ “, instance=”\\\\ “}：刮擦持续时间。\")]),e._v(\" \"),r(\"li\",[e._v(\"scrape_samples_post_metric_relabeling{job=”\\\\ “, instance=”\\\\ “}：应用度量标准重新标记后剩余的样本数。\")]),e._v(\" \"),r(\"li\",[e._v(\"scrape_samples_scraped{job=”\\\\ “, instance=”\\\\ “}：目标暴露的样本数。\")]),e._v(\" \"),r(\"li\",[e._v(\"scrape_series_added{job=”\\\\ “, instance=”\\\\ “}：该刮擦中新系列的大致数量。v2.10中的新功能。\")])]),e._v(\" \"),r(\"p\",[e._v(\"up时间序列对于实例可用性监视非常有用。\")])])}),[],!1,null,null,null);t.default=a.exports}}]);","extractedComments":[]}